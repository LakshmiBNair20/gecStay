// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AuthFailures {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function() serverError,
    required TResult Function() noInternetConnection,
    required TResult Function() userNotFound,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailAndPasswordCombinationFailure,
    required TResult Function() insufficientPermission,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function()? serverError,
    TResult? Function()? noInternetConnection,
    TResult? Function()? userNotFound,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailAndPasswordCombinationFailure,
    TResult? Function()? insufficientPermission,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function()? serverError,
    TResult Function()? noInternetConnection,
    TResult Function()? userNotFound,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailAndPasswordCombinationFailure,
    TResult Function()? insufficientPermission,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_cancelledByUser value) cancelledByUser,
    required TResult Function(_serverError value) serverError,
    required TResult Function(_noInternetConnection value) noInternetConnection,
    required TResult Function(_userNotFound value) userNotFound,
    required TResult Function(_emailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_invalidEmailAndPasswordCombinationFailure value)
        invalidEmailAndPasswordCombinationFailure,
    required TResult Function(_insufficientPermission value)
        insufficientPermission,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_cancelledByUser value)? cancelledByUser,
    TResult? Function(_serverError value)? serverError,
    TResult? Function(_noInternetConnection value)? noInternetConnection,
    TResult? Function(_userNotFound value)? userNotFound,
    TResult? Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult? Function(_insufficientPermission value)? insufficientPermission,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_cancelledByUser value)? cancelledByUser,
    TResult Function(_serverError value)? serverError,
    TResult Function(_noInternetConnection value)? noInternetConnection,
    TResult Function(_userNotFound value)? userNotFound,
    TResult Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult Function(_insufficientPermission value)? insufficientPermission,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFailuresCopyWith<$Res> {
  factory $AuthFailuresCopyWith(
          AuthFailures value, $Res Function(AuthFailures) then) =
      _$AuthFailuresCopyWithImpl<$Res, AuthFailures>;
}

/// @nodoc
class _$AuthFailuresCopyWithImpl<$Res, $Val extends AuthFailures>
    implements $AuthFailuresCopyWith<$Res> {
  _$AuthFailuresCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AuthFailures
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$cancelledByUserImplCopyWith<$Res> {
  factory _$$cancelledByUserImplCopyWith(_$cancelledByUserImpl value,
          $Res Function(_$cancelledByUserImpl) then) =
      __$$cancelledByUserImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$cancelledByUserImplCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res, _$cancelledByUserImpl>
    implements _$$cancelledByUserImplCopyWith<$Res> {
  __$$cancelledByUserImplCopyWithImpl(
      _$cancelledByUserImpl _value, $Res Function(_$cancelledByUserImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthFailures
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$cancelledByUserImpl implements _cancelledByUser {
  const _$cancelledByUserImpl();

  @override
  String toString() {
    return 'AuthFailures.cancelledByUser()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$cancelledByUserImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function() serverError,
    required TResult Function() noInternetConnection,
    required TResult Function() userNotFound,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailAndPasswordCombinationFailure,
    required TResult Function() insufficientPermission,
  }) {
    return cancelledByUser();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function()? serverError,
    TResult? Function()? noInternetConnection,
    TResult? Function()? userNotFound,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailAndPasswordCombinationFailure,
    TResult? Function()? insufficientPermission,
  }) {
    return cancelledByUser?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function()? serverError,
    TResult Function()? noInternetConnection,
    TResult Function()? userNotFound,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailAndPasswordCombinationFailure,
    TResult Function()? insufficientPermission,
    required TResult orElse(),
  }) {
    if (cancelledByUser != null) {
      return cancelledByUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_cancelledByUser value) cancelledByUser,
    required TResult Function(_serverError value) serverError,
    required TResult Function(_noInternetConnection value) noInternetConnection,
    required TResult Function(_userNotFound value) userNotFound,
    required TResult Function(_emailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_invalidEmailAndPasswordCombinationFailure value)
        invalidEmailAndPasswordCombinationFailure,
    required TResult Function(_insufficientPermission value)
        insufficientPermission,
  }) {
    return cancelledByUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_cancelledByUser value)? cancelledByUser,
    TResult? Function(_serverError value)? serverError,
    TResult? Function(_noInternetConnection value)? noInternetConnection,
    TResult? Function(_userNotFound value)? userNotFound,
    TResult? Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult? Function(_insufficientPermission value)? insufficientPermission,
  }) {
    return cancelledByUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_cancelledByUser value)? cancelledByUser,
    TResult Function(_serverError value)? serverError,
    TResult Function(_noInternetConnection value)? noInternetConnection,
    TResult Function(_userNotFound value)? userNotFound,
    TResult Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult Function(_insufficientPermission value)? insufficientPermission,
    required TResult orElse(),
  }) {
    if (cancelledByUser != null) {
      return cancelledByUser(this);
    }
    return orElse();
  }
}

abstract class _cancelledByUser implements AuthFailures {
  const factory _cancelledByUser() = _$cancelledByUserImpl;
}

/// @nodoc
abstract class _$$serverErrorImplCopyWith<$Res> {
  factory _$$serverErrorImplCopyWith(
          _$serverErrorImpl value, $Res Function(_$serverErrorImpl) then) =
      __$$serverErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$serverErrorImplCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res, _$serverErrorImpl>
    implements _$$serverErrorImplCopyWith<$Res> {
  __$$serverErrorImplCopyWithImpl(
      _$serverErrorImpl _value, $Res Function(_$serverErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthFailures
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$serverErrorImpl implements _serverError {
  const _$serverErrorImpl();

  @override
  String toString() {
    return 'AuthFailures.serverError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$serverErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function() serverError,
    required TResult Function() noInternetConnection,
    required TResult Function() userNotFound,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailAndPasswordCombinationFailure,
    required TResult Function() insufficientPermission,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function()? serverError,
    TResult? Function()? noInternetConnection,
    TResult? Function()? userNotFound,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailAndPasswordCombinationFailure,
    TResult? Function()? insufficientPermission,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function()? serverError,
    TResult Function()? noInternetConnection,
    TResult Function()? userNotFound,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailAndPasswordCombinationFailure,
    TResult Function()? insufficientPermission,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_cancelledByUser value) cancelledByUser,
    required TResult Function(_serverError value) serverError,
    required TResult Function(_noInternetConnection value) noInternetConnection,
    required TResult Function(_userNotFound value) userNotFound,
    required TResult Function(_emailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_invalidEmailAndPasswordCombinationFailure value)
        invalidEmailAndPasswordCombinationFailure,
    required TResult Function(_insufficientPermission value)
        insufficientPermission,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_cancelledByUser value)? cancelledByUser,
    TResult? Function(_serverError value)? serverError,
    TResult? Function(_noInternetConnection value)? noInternetConnection,
    TResult? Function(_userNotFound value)? userNotFound,
    TResult? Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult? Function(_insufficientPermission value)? insufficientPermission,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_cancelledByUser value)? cancelledByUser,
    TResult Function(_serverError value)? serverError,
    TResult Function(_noInternetConnection value)? noInternetConnection,
    TResult Function(_userNotFound value)? userNotFound,
    TResult Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult Function(_insufficientPermission value)? insufficientPermission,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class _serverError implements AuthFailures {
  const factory _serverError() = _$serverErrorImpl;
}

/// @nodoc
abstract class _$$noInternetConnectionImplCopyWith<$Res> {
  factory _$$noInternetConnectionImplCopyWith(_$noInternetConnectionImpl value,
          $Res Function(_$noInternetConnectionImpl) then) =
      __$$noInternetConnectionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$noInternetConnectionImplCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res, _$noInternetConnectionImpl>
    implements _$$noInternetConnectionImplCopyWith<$Res> {
  __$$noInternetConnectionImplCopyWithImpl(_$noInternetConnectionImpl _value,
      $Res Function(_$noInternetConnectionImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthFailures
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$noInternetConnectionImpl implements _noInternetConnection {
  const _$noInternetConnectionImpl();

  @override
  String toString() {
    return 'AuthFailures.noInternetConnection()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$noInternetConnectionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function() serverError,
    required TResult Function() noInternetConnection,
    required TResult Function() userNotFound,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailAndPasswordCombinationFailure,
    required TResult Function() insufficientPermission,
  }) {
    return noInternetConnection();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function()? serverError,
    TResult? Function()? noInternetConnection,
    TResult? Function()? userNotFound,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailAndPasswordCombinationFailure,
    TResult? Function()? insufficientPermission,
  }) {
    return noInternetConnection?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function()? serverError,
    TResult Function()? noInternetConnection,
    TResult Function()? userNotFound,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailAndPasswordCombinationFailure,
    TResult Function()? insufficientPermission,
    required TResult orElse(),
  }) {
    if (noInternetConnection != null) {
      return noInternetConnection();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_cancelledByUser value) cancelledByUser,
    required TResult Function(_serverError value) serverError,
    required TResult Function(_noInternetConnection value) noInternetConnection,
    required TResult Function(_userNotFound value) userNotFound,
    required TResult Function(_emailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_invalidEmailAndPasswordCombinationFailure value)
        invalidEmailAndPasswordCombinationFailure,
    required TResult Function(_insufficientPermission value)
        insufficientPermission,
  }) {
    return noInternetConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_cancelledByUser value)? cancelledByUser,
    TResult? Function(_serverError value)? serverError,
    TResult? Function(_noInternetConnection value)? noInternetConnection,
    TResult? Function(_userNotFound value)? userNotFound,
    TResult? Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult? Function(_insufficientPermission value)? insufficientPermission,
  }) {
    return noInternetConnection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_cancelledByUser value)? cancelledByUser,
    TResult Function(_serverError value)? serverError,
    TResult Function(_noInternetConnection value)? noInternetConnection,
    TResult Function(_userNotFound value)? userNotFound,
    TResult Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult Function(_insufficientPermission value)? insufficientPermission,
    required TResult orElse(),
  }) {
    if (noInternetConnection != null) {
      return noInternetConnection(this);
    }
    return orElse();
  }
}

abstract class _noInternetConnection implements AuthFailures {
  const factory _noInternetConnection() = _$noInternetConnectionImpl;
}

/// @nodoc
abstract class _$$userNotFoundImplCopyWith<$Res> {
  factory _$$userNotFoundImplCopyWith(
          _$userNotFoundImpl value, $Res Function(_$userNotFoundImpl) then) =
      __$$userNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$userNotFoundImplCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res, _$userNotFoundImpl>
    implements _$$userNotFoundImplCopyWith<$Res> {
  __$$userNotFoundImplCopyWithImpl(
      _$userNotFoundImpl _value, $Res Function(_$userNotFoundImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthFailures
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$userNotFoundImpl implements _userNotFound {
  const _$userNotFoundImpl();

  @override
  String toString() {
    return 'AuthFailures.userNotFound()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$userNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function() serverError,
    required TResult Function() noInternetConnection,
    required TResult Function() userNotFound,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailAndPasswordCombinationFailure,
    required TResult Function() insufficientPermission,
  }) {
    return userNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function()? serverError,
    TResult? Function()? noInternetConnection,
    TResult? Function()? userNotFound,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailAndPasswordCombinationFailure,
    TResult? Function()? insufficientPermission,
  }) {
    return userNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function()? serverError,
    TResult Function()? noInternetConnection,
    TResult Function()? userNotFound,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailAndPasswordCombinationFailure,
    TResult Function()? insufficientPermission,
    required TResult orElse(),
  }) {
    if (userNotFound != null) {
      return userNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_cancelledByUser value) cancelledByUser,
    required TResult Function(_serverError value) serverError,
    required TResult Function(_noInternetConnection value) noInternetConnection,
    required TResult Function(_userNotFound value) userNotFound,
    required TResult Function(_emailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_invalidEmailAndPasswordCombinationFailure value)
        invalidEmailAndPasswordCombinationFailure,
    required TResult Function(_insufficientPermission value)
        insufficientPermission,
  }) {
    return userNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_cancelledByUser value)? cancelledByUser,
    TResult? Function(_serverError value)? serverError,
    TResult? Function(_noInternetConnection value)? noInternetConnection,
    TResult? Function(_userNotFound value)? userNotFound,
    TResult? Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult? Function(_insufficientPermission value)? insufficientPermission,
  }) {
    return userNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_cancelledByUser value)? cancelledByUser,
    TResult Function(_serverError value)? serverError,
    TResult Function(_noInternetConnection value)? noInternetConnection,
    TResult Function(_userNotFound value)? userNotFound,
    TResult Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult Function(_insufficientPermission value)? insufficientPermission,
    required TResult orElse(),
  }) {
    if (userNotFound != null) {
      return userNotFound(this);
    }
    return orElse();
  }
}

abstract class _userNotFound implements AuthFailures {
  const factory _userNotFound() = _$userNotFoundImpl;
}

/// @nodoc
abstract class _$$emailAlreadyInUseImplCopyWith<$Res> {
  factory _$$emailAlreadyInUseImplCopyWith(_$emailAlreadyInUseImpl value,
          $Res Function(_$emailAlreadyInUseImpl) then) =
      __$$emailAlreadyInUseImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$emailAlreadyInUseImplCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res, _$emailAlreadyInUseImpl>
    implements _$$emailAlreadyInUseImplCopyWith<$Res> {
  __$$emailAlreadyInUseImplCopyWithImpl(_$emailAlreadyInUseImpl _value,
      $Res Function(_$emailAlreadyInUseImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthFailures
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$emailAlreadyInUseImpl implements _emailAlreadyInUse {
  const _$emailAlreadyInUseImpl();

  @override
  String toString() {
    return 'AuthFailures.emailAlreadyInUse()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$emailAlreadyInUseImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function() serverError,
    required TResult Function() noInternetConnection,
    required TResult Function() userNotFound,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailAndPasswordCombinationFailure,
    required TResult Function() insufficientPermission,
  }) {
    return emailAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function()? serverError,
    TResult? Function()? noInternetConnection,
    TResult? Function()? userNotFound,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailAndPasswordCombinationFailure,
    TResult? Function()? insufficientPermission,
  }) {
    return emailAlreadyInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function()? serverError,
    TResult Function()? noInternetConnection,
    TResult Function()? userNotFound,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailAndPasswordCombinationFailure,
    TResult Function()? insufficientPermission,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_cancelledByUser value) cancelledByUser,
    required TResult Function(_serverError value) serverError,
    required TResult Function(_noInternetConnection value) noInternetConnection,
    required TResult Function(_userNotFound value) userNotFound,
    required TResult Function(_emailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_invalidEmailAndPasswordCombinationFailure value)
        invalidEmailAndPasswordCombinationFailure,
    required TResult Function(_insufficientPermission value)
        insufficientPermission,
  }) {
    return emailAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_cancelledByUser value)? cancelledByUser,
    TResult? Function(_serverError value)? serverError,
    TResult? Function(_noInternetConnection value)? noInternetConnection,
    TResult? Function(_userNotFound value)? userNotFound,
    TResult? Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult? Function(_insufficientPermission value)? insufficientPermission,
  }) {
    return emailAlreadyInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_cancelledByUser value)? cancelledByUser,
    TResult Function(_serverError value)? serverError,
    TResult Function(_noInternetConnection value)? noInternetConnection,
    TResult Function(_userNotFound value)? userNotFound,
    TResult Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult Function(_insufficientPermission value)? insufficientPermission,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class _emailAlreadyInUse implements AuthFailures {
  const factory _emailAlreadyInUse() = _$emailAlreadyInUseImpl;
}

/// @nodoc
abstract class _$$invalidEmailAndPasswordCombinationFailureImplCopyWith<$Res> {
  factory _$$invalidEmailAndPasswordCombinationFailureImplCopyWith(
          _$invalidEmailAndPasswordCombinationFailureImpl value,
          $Res Function(_$invalidEmailAndPasswordCombinationFailureImpl) then) =
      __$$invalidEmailAndPasswordCombinationFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$invalidEmailAndPasswordCombinationFailureImplCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res,
        _$invalidEmailAndPasswordCombinationFailureImpl>
    implements _$$invalidEmailAndPasswordCombinationFailureImplCopyWith<$Res> {
  __$$invalidEmailAndPasswordCombinationFailureImplCopyWithImpl(
      _$invalidEmailAndPasswordCombinationFailureImpl _value,
      $Res Function(_$invalidEmailAndPasswordCombinationFailureImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthFailures
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$invalidEmailAndPasswordCombinationFailureImpl
    implements _invalidEmailAndPasswordCombinationFailure {
  const _$invalidEmailAndPasswordCombinationFailureImpl();

  @override
  String toString() {
    return 'AuthFailures.invalidEmailAndPasswordCombinationFailure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidEmailAndPasswordCombinationFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function() serverError,
    required TResult Function() noInternetConnection,
    required TResult Function() userNotFound,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailAndPasswordCombinationFailure,
    required TResult Function() insufficientPermission,
  }) {
    return invalidEmailAndPasswordCombinationFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function()? serverError,
    TResult? Function()? noInternetConnection,
    TResult? Function()? userNotFound,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailAndPasswordCombinationFailure,
    TResult? Function()? insufficientPermission,
  }) {
    return invalidEmailAndPasswordCombinationFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function()? serverError,
    TResult Function()? noInternetConnection,
    TResult Function()? userNotFound,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailAndPasswordCombinationFailure,
    TResult Function()? insufficientPermission,
    required TResult orElse(),
  }) {
    if (invalidEmailAndPasswordCombinationFailure != null) {
      return invalidEmailAndPasswordCombinationFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_cancelledByUser value) cancelledByUser,
    required TResult Function(_serverError value) serverError,
    required TResult Function(_noInternetConnection value) noInternetConnection,
    required TResult Function(_userNotFound value) userNotFound,
    required TResult Function(_emailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_invalidEmailAndPasswordCombinationFailure value)
        invalidEmailAndPasswordCombinationFailure,
    required TResult Function(_insufficientPermission value)
        insufficientPermission,
  }) {
    return invalidEmailAndPasswordCombinationFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_cancelledByUser value)? cancelledByUser,
    TResult? Function(_serverError value)? serverError,
    TResult? Function(_noInternetConnection value)? noInternetConnection,
    TResult? Function(_userNotFound value)? userNotFound,
    TResult? Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult? Function(_insufficientPermission value)? insufficientPermission,
  }) {
    return invalidEmailAndPasswordCombinationFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_cancelledByUser value)? cancelledByUser,
    TResult Function(_serverError value)? serverError,
    TResult Function(_noInternetConnection value)? noInternetConnection,
    TResult Function(_userNotFound value)? userNotFound,
    TResult Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult Function(_insufficientPermission value)? insufficientPermission,
    required TResult orElse(),
  }) {
    if (invalidEmailAndPasswordCombinationFailure != null) {
      return invalidEmailAndPasswordCombinationFailure(this);
    }
    return orElse();
  }
}

abstract class _invalidEmailAndPasswordCombinationFailure
    implements AuthFailures {
  const factory _invalidEmailAndPasswordCombinationFailure() =
      _$invalidEmailAndPasswordCombinationFailureImpl;
}

/// @nodoc
abstract class _$$insufficientPermissionImplCopyWith<$Res> {
  factory _$$insufficientPermissionImplCopyWith(
          _$insufficientPermissionImpl value,
          $Res Function(_$insufficientPermissionImpl) then) =
      __$$insufficientPermissionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$insufficientPermissionImplCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res, _$insufficientPermissionImpl>
    implements _$$insufficientPermissionImplCopyWith<$Res> {
  __$$insufficientPermissionImplCopyWithImpl(
      _$insufficientPermissionImpl _value,
      $Res Function(_$insufficientPermissionImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthFailures
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$insufficientPermissionImpl implements _insufficientPermission {
  const _$insufficientPermissionImpl();

  @override
  String toString() {
    return 'AuthFailures.insufficientPermission()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$insufficientPermissionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function() serverError,
    required TResult Function() noInternetConnection,
    required TResult Function() userNotFound,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidEmailAndPasswordCombinationFailure,
    required TResult Function() insufficientPermission,
  }) {
    return insufficientPermission();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function()? serverError,
    TResult? Function()? noInternetConnection,
    TResult? Function()? userNotFound,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? invalidEmailAndPasswordCombinationFailure,
    TResult? Function()? insufficientPermission,
  }) {
    return insufficientPermission?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function()? serverError,
    TResult Function()? noInternetConnection,
    TResult Function()? userNotFound,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidEmailAndPasswordCombinationFailure,
    TResult Function()? insufficientPermission,
    required TResult orElse(),
  }) {
    if (insufficientPermission != null) {
      return insufficientPermission();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_cancelledByUser value) cancelledByUser,
    required TResult Function(_serverError value) serverError,
    required TResult Function(_noInternetConnection value) noInternetConnection,
    required TResult Function(_userNotFound value) userNotFound,
    required TResult Function(_emailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_invalidEmailAndPasswordCombinationFailure value)
        invalidEmailAndPasswordCombinationFailure,
    required TResult Function(_insufficientPermission value)
        insufficientPermission,
  }) {
    return insufficientPermission(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_cancelledByUser value)? cancelledByUser,
    TResult? Function(_serverError value)? serverError,
    TResult? Function(_noInternetConnection value)? noInternetConnection,
    TResult? Function(_userNotFound value)? userNotFound,
    TResult? Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult? Function(_insufficientPermission value)? insufficientPermission,
  }) {
    return insufficientPermission?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_cancelledByUser value)? cancelledByUser,
    TResult Function(_serverError value)? serverError,
    TResult Function(_noInternetConnection value)? noInternetConnection,
    TResult Function(_userNotFound value)? userNotFound,
    TResult Function(_emailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_invalidEmailAndPasswordCombinationFailure value)?
        invalidEmailAndPasswordCombinationFailure,
    TResult Function(_insufficientPermission value)? insufficientPermission,
    required TResult orElse(),
  }) {
    if (insufficientPermission != null) {
      return insufficientPermission(this);
    }
    return orElse();
  }
}

abstract class _insufficientPermission implements AuthFailures {
  const factory _insufficientPermission() = _$insufficientPermissionImpl;
}
