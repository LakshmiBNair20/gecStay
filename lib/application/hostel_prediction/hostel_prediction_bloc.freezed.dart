// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'hostel_prediction_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HostelPredictionEvent {
  String get income => throw _privateConstructorUsedError;
  String get sgpa => throw _privateConstructorUsedError;
  String get district => throw _privateConstructorUsedError;
  String get category => throw _privateConstructorUsedError;
  String get gender => throw _privateConstructorUsedError;
  String get semester => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String income, String sgpa, String district,
            String category, String gender, String semester)
        hostelPredictionEventCalled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String income, String sgpa, String district,
            String category, String gender, String semester)?
        hostelPredictionEventCalled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String income, String sgpa, String district,
            String category, String gender, String semester)?
        hostelPredictionEventCalled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_hostelPredictionEventCalled value)
        hostelPredictionEventCalled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_hostelPredictionEventCalled value)?
        hostelPredictionEventCalled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_hostelPredictionEventCalled value)?
        hostelPredictionEventCalled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of HostelPredictionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HostelPredictionEventCopyWith<HostelPredictionEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HostelPredictionEventCopyWith<$Res> {
  factory $HostelPredictionEventCopyWith(HostelPredictionEvent value,
          $Res Function(HostelPredictionEvent) then) =
      _$HostelPredictionEventCopyWithImpl<$Res, HostelPredictionEvent>;
  @useResult
  $Res call(
      {String income,
      String sgpa,
      String district,
      String category,
      String gender,
      String semester});
}

/// @nodoc
class _$HostelPredictionEventCopyWithImpl<$Res,
        $Val extends HostelPredictionEvent>
    implements $HostelPredictionEventCopyWith<$Res> {
  _$HostelPredictionEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HostelPredictionEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? income = null,
    Object? sgpa = null,
    Object? district = null,
    Object? category = null,
    Object? gender = null,
    Object? semester = null,
  }) {
    return _then(_value.copyWith(
      income: null == income
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as String,
      sgpa: null == sgpa
          ? _value.sgpa
          : sgpa // ignore: cast_nullable_to_non_nullable
              as String,
      district: null == district
          ? _value.district
          : district // ignore: cast_nullable_to_non_nullable
              as String,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      gender: null == gender
          ? _value.gender
          : gender // ignore: cast_nullable_to_non_nullable
              as String,
      semester: null == semester
          ? _value.semester
          : semester // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$hostelPredictionEventCalledImplCopyWith<$Res>
    implements $HostelPredictionEventCopyWith<$Res> {
  factory _$$hostelPredictionEventCalledImplCopyWith(
          _$hostelPredictionEventCalledImpl value,
          $Res Function(_$hostelPredictionEventCalledImpl) then) =
      __$$hostelPredictionEventCalledImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String income,
      String sgpa,
      String district,
      String category,
      String gender,
      String semester});
}

/// @nodoc
class __$$hostelPredictionEventCalledImplCopyWithImpl<$Res>
    extends _$HostelPredictionEventCopyWithImpl<$Res,
        _$hostelPredictionEventCalledImpl>
    implements _$$hostelPredictionEventCalledImplCopyWith<$Res> {
  __$$hostelPredictionEventCalledImplCopyWithImpl(
      _$hostelPredictionEventCalledImpl _value,
      $Res Function(_$hostelPredictionEventCalledImpl) _then)
      : super(_value, _then);

  /// Create a copy of HostelPredictionEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? income = null,
    Object? sgpa = null,
    Object? district = null,
    Object? category = null,
    Object? gender = null,
    Object? semester = null,
  }) {
    return _then(_$hostelPredictionEventCalledImpl(
      income: null == income
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as String,
      sgpa: null == sgpa
          ? _value.sgpa
          : sgpa // ignore: cast_nullable_to_non_nullable
              as String,
      district: null == district
          ? _value.district
          : district // ignore: cast_nullable_to_non_nullable
              as String,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      gender: null == gender
          ? _value.gender
          : gender // ignore: cast_nullable_to_non_nullable
              as String,
      semester: null == semester
          ? _value.semester
          : semester // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$hostelPredictionEventCalledImpl
    implements _hostelPredictionEventCalled {
  const _$hostelPredictionEventCalledImpl(
      {required this.income,
      required this.sgpa,
      required this.district,
      required this.category,
      required this.gender,
      required this.semester});

  @override
  final String income;
  @override
  final String sgpa;
  @override
  final String district;
  @override
  final String category;
  @override
  final String gender;
  @override
  final String semester;

  @override
  String toString() {
    return 'HostelPredictionEvent.hostelPredictionEventCalled(income: $income, sgpa: $sgpa, district: $district, category: $category, gender: $gender, semester: $semester)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$hostelPredictionEventCalledImpl &&
            (identical(other.income, income) || other.income == income) &&
            (identical(other.sgpa, sgpa) || other.sgpa == sgpa) &&
            (identical(other.district, district) ||
                other.district == district) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.gender, gender) || other.gender == gender) &&
            (identical(other.semester, semester) ||
                other.semester == semester));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, income, sgpa, district, category, gender, semester);

  /// Create a copy of HostelPredictionEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$hostelPredictionEventCalledImplCopyWith<_$hostelPredictionEventCalledImpl>
      get copyWith => __$$hostelPredictionEventCalledImplCopyWithImpl<
          _$hostelPredictionEventCalledImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String income, String sgpa, String district,
            String category, String gender, String semester)
        hostelPredictionEventCalled,
  }) {
    return hostelPredictionEventCalled(
        income, sgpa, district, category, gender, semester);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String income, String sgpa, String district,
            String category, String gender, String semester)?
        hostelPredictionEventCalled,
  }) {
    return hostelPredictionEventCalled?.call(
        income, sgpa, district, category, gender, semester);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String income, String sgpa, String district,
            String category, String gender, String semester)?
        hostelPredictionEventCalled,
    required TResult orElse(),
  }) {
    if (hostelPredictionEventCalled != null) {
      return hostelPredictionEventCalled(
          income, sgpa, district, category, gender, semester);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_hostelPredictionEventCalled value)
        hostelPredictionEventCalled,
  }) {
    return hostelPredictionEventCalled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_hostelPredictionEventCalled value)?
        hostelPredictionEventCalled,
  }) {
    return hostelPredictionEventCalled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_hostelPredictionEventCalled value)?
        hostelPredictionEventCalled,
    required TResult orElse(),
  }) {
    if (hostelPredictionEventCalled != null) {
      return hostelPredictionEventCalled(this);
    }
    return orElse();
  }
}

abstract class _hostelPredictionEventCalled implements HostelPredictionEvent {
  const factory _hostelPredictionEventCalled(
      {required final String income,
      required final String sgpa,
      required final String district,
      required final String category,
      required final String gender,
      required final String semester}) = _$hostelPredictionEventCalledImpl;

  @override
  String get income;
  @override
  String get sgpa;
  @override
  String get district;
  @override
  String get category;
  @override
  String get gender;
  @override
  String get semester;

  /// Create a copy of HostelPredictionEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$hostelPredictionEventCalledImplCopyWith<_$hostelPredictionEventCalledImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HostelPredictionState {
  bool get isSubmitting => throw _privateConstructorUsedError;
  Option<Either<FormFailures, Map<String, dynamic>>>
      get successOrFailureOption => throw _privateConstructorUsedError;

  /// Create a copy of HostelPredictionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HostelPredictionStateCopyWith<HostelPredictionState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HostelPredictionStateCopyWith<$Res> {
  factory $HostelPredictionStateCopyWith(HostelPredictionState value,
          $Res Function(HostelPredictionState) then) =
      _$HostelPredictionStateCopyWithImpl<$Res, HostelPredictionState>;
  @useResult
  $Res call(
      {bool isSubmitting,
      Option<Either<FormFailures, Map<String, dynamic>>>
          successOrFailureOption});
}

/// @nodoc
class _$HostelPredictionStateCopyWithImpl<$Res,
        $Val extends HostelPredictionState>
    implements $HostelPredictionStateCopyWith<$Res> {
  _$HostelPredictionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HostelPredictionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSubmitting = null,
    Object? successOrFailureOption = null,
  }) {
    return _then(_value.copyWith(
      isSubmitting: null == isSubmitting
          ? _value.isSubmitting
          : isSubmitting // ignore: cast_nullable_to_non_nullable
              as bool,
      successOrFailureOption: null == successOrFailureOption
          ? _value.successOrFailureOption
          : successOrFailureOption // ignore: cast_nullable_to_non_nullable
              as Option<Either<FormFailures, Map<String, dynamic>>>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HostelPredictionStateImplCopyWith<$Res>
    implements $HostelPredictionStateCopyWith<$Res> {
  factory _$$HostelPredictionStateImplCopyWith(
          _$HostelPredictionStateImpl value,
          $Res Function(_$HostelPredictionStateImpl) then) =
      __$$HostelPredictionStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isSubmitting,
      Option<Either<FormFailures, Map<String, dynamic>>>
          successOrFailureOption});
}

/// @nodoc
class __$$HostelPredictionStateImplCopyWithImpl<$Res>
    extends _$HostelPredictionStateCopyWithImpl<$Res,
        _$HostelPredictionStateImpl>
    implements _$$HostelPredictionStateImplCopyWith<$Res> {
  __$$HostelPredictionStateImplCopyWithImpl(_$HostelPredictionStateImpl _value,
      $Res Function(_$HostelPredictionStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of HostelPredictionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSubmitting = null,
    Object? successOrFailureOption = null,
  }) {
    return _then(_$HostelPredictionStateImpl(
      isSubmitting: null == isSubmitting
          ? _value.isSubmitting
          : isSubmitting // ignore: cast_nullable_to_non_nullable
              as bool,
      successOrFailureOption: null == successOrFailureOption
          ? _value.successOrFailureOption
          : successOrFailureOption // ignore: cast_nullable_to_non_nullable
              as Option<Either<FormFailures, Map<String, dynamic>>>,
    ));
  }
}

/// @nodoc

class _$HostelPredictionStateImpl implements _HostelPredictionState {
  _$HostelPredictionStateImpl(
      {required this.isSubmitting, required this.successOrFailureOption});

  @override
  final bool isSubmitting;
  @override
  final Option<Either<FormFailures, Map<String, dynamic>>>
      successOrFailureOption;

  @override
  String toString() {
    return 'HostelPredictionState(isSubmitting: $isSubmitting, successOrFailureOption: $successOrFailureOption)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HostelPredictionStateImpl &&
            (identical(other.isSubmitting, isSubmitting) ||
                other.isSubmitting == isSubmitting) &&
            (identical(other.successOrFailureOption, successOrFailureOption) ||
                other.successOrFailureOption == successOrFailureOption));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, isSubmitting, successOrFailureOption);

  /// Create a copy of HostelPredictionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HostelPredictionStateImplCopyWith<_$HostelPredictionStateImpl>
      get copyWith => __$$HostelPredictionStateImplCopyWithImpl<
          _$HostelPredictionStateImpl>(this, _$identity);
}

abstract class _HostelPredictionState implements HostelPredictionState {
  factory _HostelPredictionState(
      {required final bool isSubmitting,
      required final Option<Either<FormFailures, Map<String, dynamic>>>
          successOrFailureOption}) = _$HostelPredictionStateImpl;

  @override
  bool get isSubmitting;
  @override
  Option<Either<FormFailures, Map<String, dynamic>>> get successOrFailureOption;

  /// Create a copy of HostelPredictionState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HostelPredictionStateImplCopyWith<_$HostelPredictionStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}
